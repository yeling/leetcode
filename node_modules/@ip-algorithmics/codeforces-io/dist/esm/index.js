var _a, _b, _c, _d;
import lineByLine from 'n-readlines';
import path from 'path';
let liner;
const callerFunction = (_d = (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : (_c = module.parent) === null || _c === void 0 ? void 0 : _c.filename) !== null && _d !== void 0 ? _d : __filename;
const pathToInput = path.format({
    root: '/',
    dir: path.dirname(callerFunction),
    base: 'input.txt'
});
const pathToOutput = path.format({
    root: '/',
    dir: path.dirname(callerFunction),
    base: 'output.txt'
});
const printedStatements = [];
/**
 * Reads the `input.txt` file from the same folder and returns it line by line. Multiple calls to this functions should be made to scan the entire file.
 * @param path - Path to the input file. Optional, defaults to ./input.txt
 * @returns return the next line of the read file or empty string on End of File - This is by design, on Algorithmic problems inputs are usually contiguous
 */
export function readline(path = pathToInput) {
    if (!liner)
        liner = new lineByLine(path);
    const line = liner.next();
    return line === false ? '' : line.toString('ascii');
}
/**
 * Prints to console the parameters
 * @param args - any
 */
export function print(...args) {
    const stringArgs = [...args].map((x) => `${x}`);
    printedStatements.push(...stringArgs);
    console.log(...args);
}
/**
 * Reads the `output.txt` file from the same folder and compares the content with what was printed to the console.
 * @param path - Path to the output file. Optional, defaults to ./output.txt
 */
export function testOutput(path = pathToOutput) {
    liner = new lineByLine(path);
    let hasPassed = true;
    let lineNumber = 0;
    let line = readline();
    while (line != '') {
        if (line !== printedStatements[lineNumber]) {
            hasPassed = false;
            break;
        }
        line = readline();
        lineNumber++;
    }
    if (hasPassed) {
        console.log('\x1b[36m%s\x1b[0m', 'Passed');
    }
    else {
        console.log('\x1b[35m%s\x1b[0m', 'Failed');
    }
}
const konsole = console;
export { konsole as console };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sVUFBVSxNQUFNLGFBQWEsQ0FBQztBQUNyQyxPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFFeEIsSUFBSSxLQUFpQixDQUFDO0FBQ3RCLE1BQU0sY0FBYyxHQUFHLE1BQUEsTUFBQSxNQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLDBDQUFFLFFBQVEsbUNBQUksTUFBQSxNQUFNLENBQUMsTUFBTSwwQ0FBRSxRQUFRLG1DQUFJLFVBQVUsQ0FBQztBQUN4RixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzVCLElBQUksRUFBRSxHQUFHO0lBQ1QsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO0lBQ2pDLElBQUksRUFBRSxXQUFXO0NBQ3BCLENBQUMsQ0FBQztBQUVILE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDN0IsSUFBSSxFQUFFLEdBQUc7SUFDVCxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7SUFDakMsSUFBSSxFQUFFLFlBQVk7Q0FDckIsQ0FBQyxDQUFDO0FBRUgsTUFBTSxpQkFBaUIsR0FBYSxFQUFFLENBQUM7QUFFdkM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQUMsSUFBSSxHQUFHLFdBQVc7SUFDdkMsSUFBSSxDQUFDLEtBQUs7UUFBRSxLQUFLLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFCLE9BQU8sSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFDLEdBQUcsSUFBVztJQUNoQyxNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDaEQsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUM7SUFDdEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsVUFBVSxDQUFDLElBQUksR0FBRyxZQUFZO0lBQzFDLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFFckIsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksSUFBSSxHQUFHLFFBQVEsRUFBRSxDQUFDO0lBRXRCLE9BQU8sSUFBSSxJQUFJLEVBQUUsRUFBRTtRQUVmLElBQUksSUFBSSxLQUFLLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3hDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDbEIsTUFBTTtTQUNUO1FBRUQsSUFBSSxHQUFHLFFBQVEsRUFBRSxDQUFDO1FBQ2xCLFVBQVUsRUFBRSxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxTQUFTLEVBQUU7UUFDWCxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQzlDO1NBQU07UUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQzlDO0FBQ0wsQ0FBQztBQUVELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUN4QixPQUFPLEVBQUUsT0FBTyxJQUFJLE9BQU8sRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxpbmVCeUxpbmUgZnJvbSAnbi1yZWFkbGluZXMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbmxldCBsaW5lcjogbGluZUJ5TGluZTtcclxuY29uc3QgY2FsbGVyRnVuY3Rpb24gPSByZXF1aXJlPy5tYWluPy5maWxlbmFtZSA/PyBtb2R1bGUucGFyZW50Py5maWxlbmFtZSA/PyBfX2ZpbGVuYW1lO1xyXG5jb25zdCBwYXRoVG9JbnB1dCA9IHBhdGguZm9ybWF0KHtcclxuICAgIHJvb3Q6ICcvJyxcclxuICAgIGRpcjogcGF0aC5kaXJuYW1lKGNhbGxlckZ1bmN0aW9uKSxcclxuICAgIGJhc2U6ICdpbnB1dC50eHQnXHJcbn0pO1xyXG5cclxuY29uc3QgcGF0aFRvT3V0cHV0ID0gcGF0aC5mb3JtYXQoe1xyXG4gICAgcm9vdDogJy8nLFxyXG4gICAgZGlyOiBwYXRoLmRpcm5hbWUoY2FsbGVyRnVuY3Rpb24pLFxyXG4gICAgYmFzZTogJ291dHB1dC50eHQnXHJcbn0pO1xyXG5cclxuY29uc3QgcHJpbnRlZFN0YXRlbWVudHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4vKipcclxuICogUmVhZHMgdGhlIGBpbnB1dC50eHRgIGZpbGUgZnJvbSB0aGUgc2FtZSBmb2xkZXIgYW5kIHJldHVybnMgaXQgbGluZSBieSBsaW5lLiBNdWx0aXBsZSBjYWxscyB0byB0aGlzIGZ1bmN0aW9ucyBzaG91bGQgYmUgbWFkZSB0byBzY2FuIHRoZSBlbnRpcmUgZmlsZS5cclxuICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIHRoZSBpbnB1dCBmaWxlLiBPcHRpb25hbCwgZGVmYXVsdHMgdG8gLi9pbnB1dC50eHRcclxuICogQHJldHVybnMgcmV0dXJuIHRoZSBuZXh0IGxpbmUgb2YgdGhlIHJlYWQgZmlsZSBvciBlbXB0eSBzdHJpbmcgb24gRW5kIG9mIEZpbGUgLSBUaGlzIGlzIGJ5IGRlc2lnbiwgb24gQWxnb3JpdGhtaWMgcHJvYmxlbXMgaW5wdXRzIGFyZSB1c3VhbGx5IGNvbnRpZ3VvdXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZWFkbGluZShwYXRoID0gcGF0aFRvSW5wdXQpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFsaW5lcikgbGluZXIgPSBuZXcgbGluZUJ5TGluZShwYXRoKTtcclxuICAgIGNvbnN0IGxpbmUgPSBsaW5lci5uZXh0KCk7XHJcbiAgICByZXR1cm4gbGluZSA9PT0gZmFsc2UgPyAnJyA6IGxpbmUudG9TdHJpbmcoJ2FzY2lpJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmludHMgdG8gY29uc29sZSB0aGUgcGFyYW1ldGVyc1xyXG4gKiBAcGFyYW0gYXJncyAtIGFueVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByaW50KC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBjb25zdCBzdHJpbmdBcmdzID0gWy4uLmFyZ3NdLm1hcCgoeCkgPT4gYCR7eH1gKTtcclxuICAgIHByaW50ZWRTdGF0ZW1lbnRzLnB1c2goLi4uc3RyaW5nQXJncyk7XHJcbiAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBgb3V0cHV0LnR4dGAgZmlsZSBmcm9tIHRoZSBzYW1lIGZvbGRlciBhbmQgY29tcGFyZXMgdGhlIGNvbnRlbnQgd2l0aCB3aGF0IHdhcyBwcmludGVkIHRvIHRoZSBjb25zb2xlLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gdGhlIG91dHB1dCBmaWxlLiBPcHRpb25hbCwgZGVmYXVsdHMgdG8gLi9vdXRwdXQudHh0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGVzdE91dHB1dChwYXRoID0gcGF0aFRvT3V0cHV0KSB7XHJcbiAgICBsaW5lciA9IG5ldyBsaW5lQnlMaW5lKHBhdGgpO1xyXG4gICAgbGV0IGhhc1Bhc3NlZCA9IHRydWU7XHJcblxyXG4gICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xyXG4gICAgbGV0IGxpbmUgPSByZWFkbGluZSgpO1xyXG5cclxuICAgIHdoaWxlIChsaW5lICE9ICcnKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxpbmUgIT09IHByaW50ZWRTdGF0ZW1lbnRzW2xpbmVOdW1iZXJdKSB7XHJcbiAgICAgICAgICAgIGhhc1Bhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmUgPSByZWFkbGluZSgpO1xyXG4gICAgICAgIGxpbmVOdW1iZXIrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzUGFzc2VkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1xceDFiWzM2bSVzXFx4MWJbMG0nLCAnUGFzc2VkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHgxYlszNW0lc1xceDFiWzBtJywgJ0ZhaWxlZCcpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBrb25zb2xlID0gY29uc29sZTtcclxuZXhwb3J0IHsga29uc29sZSBhcyBjb25zb2xlIH07XHJcbiJdfQ==