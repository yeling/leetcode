"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", { value: true });
exports.console = exports.testOutput = exports.print = exports.readline = void 0;
const n_readlines_1 = __importDefault(require("n-readlines"));
const path_1 = __importDefault(require("path"));
let liner;
const callerFunction = (_d = (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : (_c = module.parent) === null || _c === void 0 ? void 0 : _c.filename) !== null && _d !== void 0 ? _d : __filename;
const pathToInput = path_1.default.format({
    root: '/',
    dir: path_1.default.dirname(callerFunction),
    base: 'input.txt'
});
const pathToOutput = path_1.default.format({
    root: '/',
    dir: path_1.default.dirname(callerFunction),
    base: 'output.txt'
});
const printedStatements = [];
/**
 * Reads the `input.txt` file from the same folder and returns it line by line. Multiple calls to this functions should be made to scan the entire file.
 * @param path - Path to the input file. Optional, defaults to ./input.txt
 * @returns return the next line of the read file or empty string on End of File - This is by design, on Algorithmic problems inputs are usually contiguous
 */
function readline(path = pathToInput) {
    if (!liner)
        liner = new n_readlines_1.default(path);
    const line = liner.next();
    return line === false ? '' : line.toString('ascii');
}
exports.readline = readline;
/**
 * Prints to console the parameters
 * @param args - any
 */
function print(...args) {
    const stringArgs = [...args].map((x) => `${x}`);
    printedStatements.push(...stringArgs);
    console.log(...args);
}
exports.print = print;
/**
 * Reads the `output.txt` file from the same folder and compares the content with what was printed to the console.
 * @param path - Path to the output file. Optional, defaults to ./output.txt
 */
function testOutput(path = pathToOutput) {
    liner = new n_readlines_1.default(path);
    let hasPassed = true;
    let lineNumber = 0;
    let line = readline();
    while (line != '') {
        if (line !== printedStatements[lineNumber]) {
            hasPassed = false;
            break;
        }
        line = readline();
        lineNumber++;
    }
    if (hasPassed) {
        console.log('\x1b[36m%s\x1b[0m', 'Passed');
    }
    else {
        console.log('\x1b[35m%s\x1b[0m', 'Failed');
    }
}
exports.testOutput = testOutput;
const konsole = console;
exports.console = konsole;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDhEQUFxQztBQUNyQyxnREFBd0I7QUFFeEIsSUFBSSxLQUFpQixDQUFDO0FBQ3RCLE1BQU0sY0FBYyxHQUFHLE1BQUEsTUFBQSxNQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLDBDQUFFLFFBQVEsbUNBQUksTUFBQSxNQUFNLENBQUMsTUFBTSwwQ0FBRSxRQUFRLG1DQUFJLFVBQVUsQ0FBQztBQUN4RixNQUFNLFdBQVcsR0FBRyxjQUFJLENBQUMsTUFBTSxDQUFDO0lBQzVCLElBQUksRUFBRSxHQUFHO0lBQ1QsR0FBRyxFQUFFLGNBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO0lBQ2pDLElBQUksRUFBRSxXQUFXO0NBQ3BCLENBQUMsQ0FBQztBQUVILE1BQU0sWUFBWSxHQUFHLGNBQUksQ0FBQyxNQUFNLENBQUM7SUFDN0IsSUFBSSxFQUFFLEdBQUc7SUFDVCxHQUFHLEVBQUUsY0FBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7SUFDakMsSUFBSSxFQUFFLFlBQVk7Q0FDckIsQ0FBQyxDQUFDO0FBRUgsTUFBTSxpQkFBaUIsR0FBYSxFQUFFLENBQUM7QUFFdkM7Ozs7R0FJRztBQUNILFNBQWdCLFFBQVEsQ0FBQyxJQUFJLEdBQUcsV0FBVztJQUN2QyxJQUFJLENBQUMsS0FBSztRQUFFLEtBQUssR0FBRyxJQUFJLHFCQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFCLE9BQU8sSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFKRCw0QkFJQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLEtBQUssQ0FBQyxHQUFHLElBQVc7SUFDaEMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2hELGlCQUFpQixDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN6QixDQUFDO0FBSkQsc0JBSUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixVQUFVLENBQUMsSUFBSSxHQUFHLFlBQVk7SUFDMUMsS0FBSyxHQUFHLElBQUkscUJBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFFckIsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksSUFBSSxHQUFHLFFBQVEsRUFBRSxDQUFDO0lBRXRCLE9BQU8sSUFBSSxJQUFJLEVBQUUsRUFBRTtRQUVmLElBQUksSUFBSSxLQUFLLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3hDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDbEIsTUFBTTtTQUNUO1FBRUQsSUFBSSxHQUFHLFFBQVEsRUFBRSxDQUFDO1FBQ2xCLFVBQVUsRUFBRSxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxTQUFTLEVBQUU7UUFDWCxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQzlDO1NBQU07UUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQzlDO0FBQ0wsQ0FBQztBQXZCRCxnQ0F1QkM7QUFFRCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDSiwwQkFBTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsaW5lQnlMaW5lIGZyb20gJ24tcmVhZGxpbmVzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5sZXQgbGluZXI6IGxpbmVCeUxpbmU7XHJcbmNvbnN0IGNhbGxlckZ1bmN0aW9uID0gcmVxdWlyZT8ubWFpbj8uZmlsZW5hbWUgPz8gbW9kdWxlLnBhcmVudD8uZmlsZW5hbWUgPz8gX19maWxlbmFtZTtcclxuY29uc3QgcGF0aFRvSW5wdXQgPSBwYXRoLmZvcm1hdCh7XHJcbiAgICByb290OiAnLycsXHJcbiAgICBkaXI6IHBhdGguZGlybmFtZShjYWxsZXJGdW5jdGlvbiksXHJcbiAgICBiYXNlOiAnaW5wdXQudHh0J1xyXG59KTtcclxuXHJcbmNvbnN0IHBhdGhUb091dHB1dCA9IHBhdGguZm9ybWF0KHtcclxuICAgIHJvb3Q6ICcvJyxcclxuICAgIGRpcjogcGF0aC5kaXJuYW1lKGNhbGxlckZ1bmN0aW9uKSxcclxuICAgIGJhc2U6ICdvdXRwdXQudHh0J1xyXG59KTtcclxuXHJcbmNvbnN0IHByaW50ZWRTdGF0ZW1lbnRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBgaW5wdXQudHh0YCBmaWxlIGZyb20gdGhlIHNhbWUgZm9sZGVyIGFuZCByZXR1cm5zIGl0IGxpbmUgYnkgbGluZS4gTXVsdGlwbGUgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbnMgc2hvdWxkIGJlIG1hZGUgdG8gc2NhbiB0aGUgZW50aXJlIGZpbGUuXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byB0aGUgaW5wdXQgZmlsZS4gT3B0aW9uYWwsIGRlZmF1bHRzIHRvIC4vaW5wdXQudHh0XHJcbiAqIEByZXR1cm5zIHJldHVybiB0aGUgbmV4dCBsaW5lIG9mIHRoZSByZWFkIGZpbGUgb3IgZW1wdHkgc3RyaW5nIG9uIEVuZCBvZiBGaWxlIC0gVGhpcyBpcyBieSBkZXNpZ24sIG9uIEFsZ29yaXRobWljIHByb2JsZW1zIGlucHV0cyBhcmUgdXN1YWxseSBjb250aWd1b3VzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVhZGxpbmUocGF0aCA9IHBhdGhUb0lucHV0KTogc3RyaW5nIHtcclxuICAgIGlmICghbGluZXIpIGxpbmVyID0gbmV3IGxpbmVCeUxpbmUocGF0aCk7XHJcbiAgICBjb25zdCBsaW5lID0gbGluZXIubmV4dCgpO1xyXG4gICAgcmV0dXJuIGxpbmUgPT09IGZhbHNlID8gJycgOiBsaW5lLnRvU3RyaW5nKCdhc2NpaScpO1xyXG59XHJcblxyXG4vKipcclxuICogUHJpbnRzIHRvIGNvbnNvbGUgdGhlIHBhcmFtZXRlcnNcclxuICogQHBhcmFtIGFyZ3MgLSBhbnlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmludCguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgY29uc3Qgc3RyaW5nQXJncyA9IFsuLi5hcmdzXS5tYXAoKHgpID0+IGAke3h9YCk7XHJcbiAgICBwcmludGVkU3RhdGVtZW50cy5wdXNoKC4uLnN0cmluZ0FyZ3MpO1xyXG4gICAgY29uc29sZS5sb2coLi4uYXJncyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyB0aGUgYG91dHB1dC50eHRgIGZpbGUgZnJvbSB0aGUgc2FtZSBmb2xkZXIgYW5kIGNvbXBhcmVzIHRoZSBjb250ZW50IHdpdGggd2hhdCB3YXMgcHJpbnRlZCB0byB0aGUgY29uc29sZS5cclxuICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIHRoZSBvdXRwdXQgZmlsZS4gT3B0aW9uYWwsIGRlZmF1bHRzIHRvIC4vb3V0cHV0LnR4dFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RPdXRwdXQocGF0aCA9IHBhdGhUb091dHB1dCkge1xyXG4gICAgbGluZXIgPSBuZXcgbGluZUJ5TGluZShwYXRoKTtcclxuICAgIGxldCBoYXNQYXNzZWQgPSB0cnVlO1xyXG5cclxuICAgIGxldCBsaW5lTnVtYmVyID0gMDtcclxuICAgIGxldCBsaW5lID0gcmVhZGxpbmUoKTtcclxuXHJcbiAgICB3aGlsZSAobGluZSAhPSAnJykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsaW5lICE9PSBwcmludGVkU3RhdGVtZW50c1tsaW5lTnVtYmVyXSkge1xyXG4gICAgICAgICAgICBoYXNQYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsaW5lID0gcmVhZGxpbmUoKTtcclxuICAgICAgICBsaW5lTnVtYmVyKys7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc1Bhc3NlZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXHgxYlszNm0lc1xceDFiWzBtJywgJ1Bhc3NlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnXFx4MWJbMzVtJXNcXHgxYlswbScsICdGYWlsZWQnKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3Qga29uc29sZSA9IGNvbnNvbGU7XHJcbmV4cG9ydCB7IGtvbnNvbGUgYXMgY29uc29sZSB9O1xyXG4iXX0=